{"version":3,"file":"react-soft-slider.cjs.production.min.js","sources":["../src/index.tsx"],"sourcesContent":["import React, { useRef, useEffect } from 'react'\nimport { useSprings, animated, SpringConfig } from 'react-spring'\nimport { useDrag } from 'react-use-gesture'\nimport useResizeObserver from 'use-resize-observer'\n\ntype SliderProps = {\n  children: React.ReactNode[]\n  index: number\n  onIndexChange: (newIndex: number) => void\n  className?: string\n  style?: React.CSSProperties\n  slideClassName?: string\n  slideStyle?: React.CSSProperties | ((index: number) => React.CSSProperties)\n  indexRange?: [number, number]\n  onDragStart?: (pressedIndex: number) => void\n  onDragEnd?: (pressedIndex: number) => void\n  onTap?: (pressedIndex: number) => void\n} & typeof defaultProps\n\nconst defaultProps = {\n  enabled: true,\n  vertical: false,\n  slideAlign: 'center',\n  draggedScale: 1,\n  draggedSpring: { tension: 1200, friction: 40 } as SpringConfig,\n  trailingSpring: { tension: 120, friction: 30 } as SpringConfig,\n  releaseSpring: { tension: 120, friction: 30 } as SpringConfig,\n  trailingDelay: 50\n}\n\n// style for the slides wrapper\nconst slidesWrapperStyle = (vertical: boolean): React.CSSProperties => ({\n  display: 'flex',\n  flexWrap: 'nowrap',\n  alignItems: 'stretch',\n  position: 'relative',\n  WebkitUserSelect: 'none',\n  userSelect: 'none',\n  WebkitTouchCallout: 'none',\n  flexDirection: vertical ? 'column' : 'row',\n  touchAction: vertical ? 'pan-x' : 'pan-y'\n})\n\nconst clamp = (num: number, clamp: number, higher: number) =>\n  Math.min(Math.max(num, clamp), higher)\n\nexport const Slider = ({\n  children,\n  index,\n  onIndexChange,\n  className,\n  style,\n  slideStyle,\n  slideClassName,\n  enabled,\n  vertical,\n  indexRange,\n  slideAlign,\n  draggedScale,\n  draggedSpring,\n  releaseSpring,\n  trailingSpring,\n  trailingDelay,\n  onDragStart,\n  onDragEnd,\n  onTap\n}: SliderProps) => {\n  const slideStyleFunc =\n    typeof slideStyle === 'function' ? slideStyle : () => slideStyle\n  // root holds are slides wrapper node and we use a ResizeObserver\n  // to observe its size in order to recompute the slides position\n  // when it changes\n  const root = useRef<HTMLInputElement>(null)\n  const { width, height } = useResizeObserver({ ref: root })\n\n  const axis = vertical ? 'y' : 'x'\n  const size = vertical ? height : width\n\n  let [minIndex, maxIndex] = indexRange || [0, children.length - 1]\n  maxIndex = maxIndex > 0 ? maxIndex : children.length - 1 + maxIndex\n\n  // indexRef is an internal reference to the current slide index\n  const indexRef = useRef(index)\n\n  // restPos holds a reference to the adjusted position of the slider\n  // when rested\n  const restPos = useRef(0)\n  const velocity = useRef(0)\n\n  // visibleIndexes is a Set holding the index of slides that are\n  // currently partially or fully visible (intersecting) in the\n  // viewport\n  const visibleIndexes = useRef(new Set<number>())\n  const firstVisibleIndex = useRef(0)\n  const lastVisibleIndex = useRef(0)\n\n  // instances holds a ref to an array of controllers\n  // to simulate a spring trail. Mechanics is directly\n  // copied from here https://github.com/react-spring/react-spring/blob/31200a79843ce85200b2a7692e8f14788e60f9e9/src/useTrail.js#L14\n  // const instances = useRef()\n\n  // callback called by the intersection observer updating\n  // visibleIndexes\n  const cb: IntersectionObserverCallback = slides => {\n    slides.forEach(({ isIntersecting, target }) =>\n      visibleIndexes.current[isIntersecting ? 'add' : 'delete'](\n        Number(target.getAttribute('data-index'))\n      )\n    )\n    const visibles = Array.from(visibleIndexes.current).sort()\n    firstVisibleIndex.current = visibles[0]\n    lastVisibleIndex.current = visibles[visibles.length - 1]\n  }\n\n  const observer = useRef<IntersectionObserver | null>(null)\n\n  // we add the slides to the IntersectionObserver:\n  // this is recomputed everytime the user adds or removes a slide\n  useEffect(() => {\n    if (!observer.current) observer.current = new IntersectionObserver(cb)\n    Array.from(root.current!.children).forEach(t =>\n      observer.current!.observe(t)\n    )\n    return () => observer.current!.disconnect()\n  }, [children.length, root])\n\n  // setting the springs with initial position set to restPos:\n  // this is important when adding slides since changing children\n  // length recomputes useSprings\n  const [springs, set] = useSprings(children.length, _i => {\n    // zIndex will make sure the dragged slide stays on top of the others\n    return {\n      x: vertical ? 0 : restPos.current,\n      y: vertical ? restPos.current : 0,\n      s: 1,\n      zIndex: 0,\n      immediate: key => key === 'zIndex'\n    }\n  })\n\n  // everytime the index changes, we should calculate the right position\n  // of the slide so that its centered: this is recomputed everytime\n  // the index changes\n  useEffect(() => {\n    // if width and height haven't been set don't do anything\n    // (this happens on first render before useResizeObserver had the time to kick in)\n    if (!width || !height) return\n    // here we take the selected slide\n    // and calculate its position so its centered in the slides wrapper\n    if (vertical) {\n      const { offsetTop, offsetHeight } = root.current!.children[\n        index\n      ] as HTMLElement\n      restPos.current = Math.round(-offsetTop + (height - offsetHeight) / 2)\n    } else {\n      const { offsetLeft, offsetWidth } = root.current!.children[\n        index\n      ] as HTMLElement\n      restPos.current = Math.round(-offsetLeft + (width - offsetWidth) / 2)\n    }\n    // two options then:\n    // 1. the index was changed through gestures: in that case indexRef\n    // is equal to index, we just want to set the position where it should\n\n    if (indexRef.current === index) {\n      set(_i => ({\n        [axis]: restPos.current,\n        s: 1,\n        config: { ...releaseSpring, velocity: velocity.current }\n        // config: key =>\n        //   key === axis\n        //     ? { ...releaseSpring, velocity: velocity.current }\n        //     : undefined,\n      }))\n    } else {\n      // 2. the user has changed the index props: in that case indexRef\n      // is outdated and different from index. We want to animate depending\n      // on the direction of the slide, with the furthest slide moving first\n      // trailing the others\n\n      const dir = index < indexRef.current ? -1 : 1\n      // if direction is 1 then the first slide to animate should be the lowest\n      // indexed visible slide, if -1 the highest\n      const firstToMove =\n        dir > 0 ? firstVisibleIndex.current : lastVisibleIndex.current\n      set(i => {\n        return {\n          [axis]: restPos.current,\n          s: 1,\n          // config: key => key === axis && releaseSpring,\n          config: releaseSpring,\n          delay:\n            i * dir < firstToMove * dir\n              ? 0\n              : Math.abs(firstToMove - i) * trailingDelay\n        }\n      })\n    }\n    // finally we update indexRef to match index\n    indexRef.current = index\n  }, [\n    index,\n    set,\n    root,\n    vertical,\n    axis,\n    height,\n    width,\n    releaseSpring,\n    draggedSpring,\n    trailingDelay\n  ])\n\n  // adding the bind listener\n  const bind = useDrag(\n    ({\n      first,\n      last,\n      tap,\n      vxvy: [vx, vy],\n      delta: [dx, dy],\n      swipe: [sx, sy],\n      movement: [movX, movY],\n      args: [pressedIndex],\n      memo = springs[pressedIndex][axis].getValue()\n    }) => {\n      if (tap) {\n        onTap && onTap(pressedIndex)\n        return\n      }\n      const v = vertical ? vy : vx\n      const dir = -Math.sign(vertical ? dy : dx)\n      const mov = vertical ? movY : movX\n      const swipe = vertical ? sy : sx\n\n      if (first) {\n        // if this is the first drag event, we're trailing the controllers\n        // to the index being dragged and setting zIndex, scale and config\n        set(i => {\n          return {\n            [axis]: memo + mov,\n            s: draggedScale,\n            config: key =>\n              key === axis && i === pressedIndex\n                ? draggedSpring\n                : trailingSpring,\n            zIndex: i === pressedIndex ? 10 : 0\n          }\n        })\n\n        // triggering onDragStart prop if it exists\n        onDragStart && onDragStart(pressedIndex)\n      } else if (last) {\n        // when the user releases the drag and the distance or speed are superior to a threshold\n        // we update the indexRef\n        if (Math.abs(mov) > size! / 2 || swipe !== 0) {\n          indexRef.current = clamp(\n            indexRef.current + (mov > 0 ? -1 : 1),\n            minIndex,\n            maxIndex\n          )\n        }\n        // if the index is not equal to indexRef we know we've moved a slide\n        // so we tell the user to update its index in the next tick and our useEffect\n        // will do the rest. RAF is used to make sure we're not updating the index\n        // too fast: that might happen if the user wants to update a slide onClick\n        // TODO - need an example\n        if (index !== indexRef.current) {\n          velocity.current = v\n          requestAnimationFrame(() => onIndexChange(indexRef.current))\n        }\n        // if the index hasn't changed then we set the position back to where it should be\n        else\n          set(() => ({\n            [axis]: restPos.current,\n            s: 1,\n            // config: key => key === axis && releaseSpring,\n            config: releaseSpring\n          }))\n\n        // triggering onDragEnd prop if it exists\n        onDragEnd && onDragEnd(pressedIndex)\n      }\n\n      // if not we're just dragging and we're just updating the position\n      else {\n        const firstToMove =\n          dir > 0 ? firstVisibleIndex.current : lastVisibleIndex.current\n        set(i => {\n          return {\n            [axis]: mov + memo,\n            delay:\n              i * dir < firstToMove * dir || i === pressedIndex\n                ? 0\n                : Math.abs(firstToMove - i) * trailingDelay,\n            config: key =>\n              key === axis && i === pressedIndex\n                ? draggedSpring\n                : trailingSpring\n          }\n        })\n      }\n\n      // and returning memo to keep the initial position in cache along drag\n      return memo\n    },\n    { enabled, axis, filterTaps: true }\n  )\n\n  const rootStyle = slidesWrapperStyle(vertical)\n  if (!className) rootStyle.width = '100%'\n\n  return (\n    <div ref={root} className={className} style={{ ...rootStyle, ...style }}>\n      {springs.map(({ [axis]: pos, s, zIndex }, i) => (\n        <animated.div\n          // passing the index as an argument will let our handler know\n          // which slide is being dragged\n          {...bind(i)}\n          key={i}\n          data-index={i}\n          className={slideClassName}\n          style={{\n            [vertical ? 'justifyContent' : 'alignItems']: slideAlign,\n            display: 'flex',\n            ...slideStyleFunc(i),\n            zIndex,\n            [axis]: pos,\n            scale: s,\n            willChange: 'transform'\n          }}\n        >\n          {children[i]}\n        </animated.div>\n      ))}\n    </div>\n  )\n}\n\nSlider.defaultProps = defaultProps\n"],"names":["Slider","children","index","onIndexChange","className","style","slideStyle","slideClassName","enabled","vertical","indexRange","slideAlign","draggedScale","draggedSpring","releaseSpring","trailingSpring","trailingDelay","onDragStart","onDragEnd","onTap","slideStyleFunc","root","useRef","useResizeObserver","ref","width","height","axis","size","length","minIndex","maxIndex","indexRef","restPos","velocity","visibleIndexes","Set","firstVisibleIndex","lastVisibleIndex","cb","slides","forEach","current","isIntersecting","Number","target","getAttribute","visibles","Array","from","sort","observer","useEffect","IntersectionObserver","t","observe","disconnect","useSprings","_i","x","y","s","zIndex","immediate","key","springs","set","Math","round","offsetHeight","offsetTop","offsetWidth","offsetLeft","config","dir","firstToMove","i","delay","abs","bind","useDrag","first","last","tap","vxvy","vx","vy","delta","dx","dy","swipe","sx","sy","movement","movX","movY","pressedIndex","args","memo","getValue","higher","v","sign","mov","min","max","requestAnimationFrame","filterTaps","rootStyle","display","flexWrap","alignItems","position","WebkitUserSelect","userSelect","WebkitTouchCallout","flexDirection","touchAction","slidesWrapperStyle","React","map","pos","animated","div","scale","willChange","defaultProps","tension","friction"],"mappings":"odAmBA,IA2BaA,EAAS,gBACpBC,IAAAA,SACAC,IAAAA,MACAC,IAAAA,cACAC,IAAAA,UACAC,IAAAA,MACAC,IAAAA,WACAC,IAAAA,eACAC,IAAAA,QACAC,IAAAA,SACAC,IAAAA,WACAC,IAAAA,WACAC,IAAAA,aACAC,IAAAA,cACAC,IAAAA,cACAC,IAAAA,eACAC,IAAAA,cACAC,IAAAA,YACAC,IAAAA,UACAC,IAAAA,MAEMC,EACkB,mBAAfd,EAA4BA,EAAa,kBAAMA,GAIlDe,EAAOC,SAAyB,QACZC,EAAkB,CAAEC,IAAKH,IAA3CI,IAAAA,MAAOC,IAAAA,OAETC,EAAOlB,EAAW,IAAM,IACxBmB,EAAOnB,EAAWiB,EAASD,IAENf,GAAc,CAAC,EAAGT,EAAS4B,OAAS,GAA1DC,OAAUC,OACfA,EAAWA,EAAW,EAAIA,EAAW9B,EAAS4B,OAAS,EAAIE,MAGrDC,EAAWV,SAAOpB,GAIlB+B,EAAUX,SAAO,GACjBY,EAAWZ,SAAO,GAKlBa,EAAiBb,SAAO,IAAIc,KAC5BC,EAAoBf,SAAO,GAC3BgB,EAAmBhB,SAAO,GAS1BiB,EAAmC,SAAAC,GACvCA,EAAOC,SAAQ,mBACbN,EAAeO,UADCC,eACwB,MAAQ,UAC9CC,SAF8BC,OAEhBC,aAAa,uBAGzBC,EAAWC,MAAMC,KAAKd,EAAeO,SAASQ,OACpDb,EAAkBK,QAAUK,EAAS,GACrCT,EAAiBI,QAAUK,EAASA,EAASlB,OAAS,IAGlDsB,EAAW7B,SAAoC,MAIrD8B,aAAU,kBACHD,EAAST,UAASS,EAAST,QAAU,IAAIW,qBAAqBd,IACnES,MAAMC,KAAK5B,EAAKqB,QAASzC,UAAUwC,SAAQ,SAAAa,UACzCH,EAAST,QAASa,QAAQD,MAErB,kBAAMH,EAAST,QAASc,gBAC9B,CAACvD,EAAS4B,OAAQR,UAKEoC,aAAWxD,EAAS4B,QAAQ,SAAA6B,SAE1C,CACLC,EAAGlD,EAAW,EAAIwB,EAAQS,QAC1BkB,EAAGnD,EAAWwB,EAAQS,QAAU,EAChCmB,EAAG,EACHC,OAAQ,EACRC,UAAW,SAAAC,SAAe,WAARA,OAPfC,OAASC,OAchBd,aAAU,cAGH3B,GAAUC,MAGXjB,EAAU,OACwBY,EAAKqB,QAASzC,SAChDC,GAEF+B,EAAQS,QAAUyB,KAAKC,OAAoB1C,IAHxB2C,cAGiD,IAH5DC,eAIH,OAC+BjD,EAAKqB,QAASzC,SAChDC,GAEF+B,EAAQS,QAAUyB,KAAKC,OAAqB3C,IAHxB8C,aAG+C,IAH3DC,eASNxC,EAASU,UAAYxC,EACvBgE,GAAI,SAAAR,sBACD/B,GAAOM,EAAQS,UAChBmB,EAAG,IACHY,YAAa3D,GAAeoB,SAAUA,EAASQ,mBAM5C,KAMCgC,EAAMxE,EAAQ8B,EAASU,SAAW,EAAI,EAGtCiC,EACJD,EAAM,EAAIrC,EAAkBK,QAAUJ,EAAiBI,QACzDwB,GAAI,SAAAU,sBAECjD,GAAOM,EAAQS,UAChBmB,EAAG,IAEHY,OAAQ3D,IACR+D,MACED,EAAIF,EAAMC,EAAcD,EACpB,EACAP,KAAKW,IAAIH,EAAcC,GAAK5D,OAKxCgB,EAASU,QAAUxC,KAClB,CACDA,EACAgE,EACA7C,EACAZ,EACAkB,EACAD,EACAD,EACAX,EACAD,EACAG,QAII+D,EAAOC,WACX,gBACEC,IAAAA,MACAC,IAAAA,KACAC,IAAAA,QACAC,KAAOC,OAAIC,WACXC,MAAQC,OAAIC,WACZC,MAAQC,OAAIC,WACZC,SAAWC,OAAMC,OACVC,IAAPC,YACAC,KAAAA,aAAOjC,EAAQ+B,GAAcrE,GAAMwE,iBAE/BhB,OAvLiCiB,EA2L/BC,EAAI5F,EAAW6E,EAAKD,EACpBX,GAAOP,KAAKmC,KAAK7F,EAAWgF,EAAKD,GACjCe,EAAM9F,EAAWsF,EAAOD,EACxBJ,EAAQjF,EAAWmF,EAAKD,KAE1BV,EAGFf,GAAI,SAAAU,sBAECjD,GAAOuE,EAAOK,IACf1C,EAAGjD,IACH6D,OAAQ,SAAAT,UACNA,IAAQrC,GAAQiD,IAAMoB,EAClBnF,EACAE,KACN+C,OAAQc,IAAMoB,EAAe,GAAK,OAKtC/E,GAAeA,EAAY+E,QACtB,GAAId,GAGLf,KAAKW,IAAIyB,GAAO3E,EAAQ,GAAe,IAAV8D,KAC/B1D,EAASU,SArNwB0D,EAwN/BrE,EAvNVoC,KAAKqC,IAAIrC,KAAKsC,IAqNJzE,EAASU,SAAW6D,EAAM,GAAK,EAAI,GACnCzE,GAtNqBsE,KA+NrBlG,IAAU8B,EAASU,SACrBR,EAASQ,QAAU2D,EACnBK,uBAAsB,kBAAMvG,EAAc6B,EAASU,aAInDwB,GAAI,8BACDvC,GAAOM,EAAQS,UAChBmB,EAAG,IAEHY,OAAQ3D,OAIZI,GAAaA,EAAU8E,OAIpB,KACGrB,EACJD,EAAM,EAAIrC,EAAkBK,QAAUJ,EAAiBI,QACzDwB,GAAI,SAAAU,sBAECjD,GAAO4E,EAAML,IACdrB,MACED,EAAIF,EAAMC,EAAcD,GAAOE,IAAMoB,EACjC,EACA7B,KAAKW,IAAIH,EAAcC,GAAK5D,IAClCyD,OAAQ,SAAAT,UACNA,IAAQrC,GAAQiD,IAAMoB,EAClBnF,EACAE,eAMLmF,EA7EL/E,GAASA,EAAM6E,KA+EnB,CAAExF,QAAAA,EAASmB,KAAAA,EAAMgF,YAAY,IAGzBC,EAtRmB,SAACnG,SAA4C,CACtEoG,QAAS,OACTC,SAAU,SACVC,WAAY,UACZC,SAAU,WACVC,iBAAkB,OAClBC,WAAY,OACZC,mBAAoB,OACpBC,cAAe3G,EAAW,SAAW,MACrC4G,YAAa5G,EAAW,QAAU,SA6QhB6G,CAAmB7G,UAChCL,IAAWwG,EAAUnF,MAAQ,QAGhC8F,uBAAK/F,IAAKH,EAAMjB,UAAWA,EAAWC,WAAYuG,KAAcvG,IAC7D4D,EAAQuD,KAAI,WAA6B5C,WAAlB6C,IAAP9F,GAAYkC,IAAAA,EAAGC,IAAAA,cAC9ByD,gBAACG,WAASC,qBAGJ5C,EAAKH,IACTZ,IAAKY,eACOA,EACZxE,UAAWG,EACXF,gBACGI,EAAW,iBAAmB,cAAeE,IAC9CkG,QAAS,UACNzF,EAAewD,OAClBd,OAAAA,KACCnC,GAAO8F,IACRG,MAAO/D,IACPgE,WAAY,kBAGb5H,EAAS2E,SAOpB5E,EAAO8H,aAhUc,CACnBtH,SAAS,EACTC,UAAU,EACVE,WAAY,SACZC,aAAc,EACdC,cAAe,CAAEkH,QAAS,KAAMC,SAAU,IAC1CjH,eAAgB,CAAEgH,QAAS,IAAKC,SAAU,IAC1ClH,cAAe,CAAEiH,QAAS,IAAKC,SAAU,IACzChH,cAAe"}