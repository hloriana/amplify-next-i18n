'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var reactSpring = require('react-spring');
var reactUseGesture = require('react-use-gesture');
var useResizeObserver = _interopDefault(require('use-resize-observer'));

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var defaultProps = {
  enabled: true,
  vertical: false,
  slideAlign: 'center',
  draggedScale: 1,
  draggedSpring: {
    tension: 1200,
    friction: 40
  },
  trailingSpring: {
    tension: 120,
    friction: 30
  },
  releaseSpring: {
    tension: 120,
    friction: 30
  },
  trailingDelay: 50
}; // style for the slides wrapper

var slidesWrapperStyle = function slidesWrapperStyle(vertical) {
  return {
    display: 'flex',
    flexWrap: 'nowrap',
    alignItems: 'stretch',
    position: 'relative',
    WebkitUserSelect: 'none',
    userSelect: 'none',
    WebkitTouchCallout: 'none',
    flexDirection: vertical ? 'column' : 'row',
    touchAction: vertical ? 'pan-x' : 'pan-y'
  };
};

var clamp = function clamp(num, _clamp, higher) {
  return Math.min(Math.max(num, _clamp), higher);
};

var Slider = function Slider(_ref) {
  var children = _ref.children,
      index = _ref.index,
      onIndexChange = _ref.onIndexChange,
      className = _ref.className,
      style = _ref.style,
      slideStyle = _ref.slideStyle,
      slideClassName = _ref.slideClassName,
      enabled = _ref.enabled,
      vertical = _ref.vertical,
      indexRange = _ref.indexRange,
      slideAlign = _ref.slideAlign,
      draggedScale = _ref.draggedScale,
      draggedSpring = _ref.draggedSpring,
      releaseSpring = _ref.releaseSpring,
      trailingSpring = _ref.trailingSpring,
      trailingDelay = _ref.trailingDelay,
      onDragStart = _ref.onDragStart,
      onDragEnd = _ref.onDragEnd,
      onTap = _ref.onTap;
  var slideStyleFunc = typeof slideStyle === 'function' ? slideStyle : function () {
    return slideStyle;
  }; // root holds are slides wrapper node and we use a ResizeObserver
  // to observe its size in order to recompute the slides position
  // when it changes

  var root = React.useRef(null);

  var _useResizeObserver = useResizeObserver({
    ref: root
  }),
      width = _useResizeObserver.width,
      height = _useResizeObserver.height;

  var axis = vertical ? 'y' : 'x';
  var size = vertical ? height : width;

  var _ref2 = indexRange || [0, children.length - 1],
      minIndex = _ref2[0],
      maxIndex = _ref2[1];

  maxIndex = maxIndex > 0 ? maxIndex : children.length - 1 + maxIndex; // indexRef is an internal reference to the current slide index

  var indexRef = React.useRef(index); // restPos holds a reference to the adjusted position of the slider
  // when rested

  var restPos = React.useRef(0);
  var velocity = React.useRef(0); // visibleIndexes is a Set holding the index of slides that are
  // currently partially or fully visible (intersecting) in the
  // viewport

  var visibleIndexes = React.useRef(new Set());
  var firstVisibleIndex = React.useRef(0);
  var lastVisibleIndex = React.useRef(0); // instances holds a ref to an array of controllers
  // to simulate a spring trail. Mechanics is directly
  // copied from here https://github.com/react-spring/react-spring/blob/31200a79843ce85200b2a7692e8f14788e60f9e9/src/useTrail.js#L14
  // const instances = useRef()
  // callback called by the intersection observer updating
  // visibleIndexes

  var cb = function cb(slides) {
    slides.forEach(function (_ref3) {
      var isIntersecting = _ref3.isIntersecting,
          target = _ref3.target;
      return visibleIndexes.current[isIntersecting ? 'add' : 'delete'](Number(target.getAttribute('data-index')));
    });
    var visibles = Array.from(visibleIndexes.current).sort();
    firstVisibleIndex.current = visibles[0];
    lastVisibleIndex.current = visibles[visibles.length - 1];
  };

  var observer = React.useRef(null); // we add the slides to the IntersectionObserver:
  // this is recomputed everytime the user adds or removes a slide

  React.useEffect(function () {
    if (!observer.current) observer.current = new IntersectionObserver(cb);
    Array.from(root.current.children).forEach(function (t) {
      return observer.current.observe(t);
    });
    return function () {
      return observer.current.disconnect();
    };
  }, [children.length, root]); // setting the springs with initial position set to restPos:
  // this is important when adding slides since changing children
  // length recomputes useSprings

  var _useSprings = reactSpring.useSprings(children.length, function (_i) {
    // zIndex will make sure the dragged slide stays on top of the others
    return {
      x: vertical ? 0 : restPos.current,
      y: vertical ? restPos.current : 0,
      s: 1,
      zIndex: 0,
      immediate: function immediate(key) {
        return key === 'zIndex';
      }
    };
  }),
      springs = _useSprings[0],
      set = _useSprings[1]; // everytime the index changes, we should calculate the right position
  // of the slide so that its centered: this is recomputed everytime
  // the index changes


  React.useEffect(function () {
    // if width and height haven't been set don't do anything
    // (this happens on first render before useResizeObserver had the time to kick in)
    if (!width || !height) return; // here we take the selected slide
    // and calculate its position so its centered in the slides wrapper

    if (vertical) {
      var _root$current$childre = root.current.children[index],
          offsetTop = _root$current$childre.offsetTop,
          offsetHeight = _root$current$childre.offsetHeight;
      restPos.current = Math.round(-offsetTop + (height - offsetHeight) / 2);
    } else {
      var _root$current$childre2 = root.current.children[index],
          offsetLeft = _root$current$childre2.offsetLeft,
          offsetWidth = _root$current$childre2.offsetWidth;
      restPos.current = Math.round(-offsetLeft + (width - offsetWidth) / 2);
    } // two options then:
    // 1. the index was changed through gestures: in that case indexRef
    // is equal to index, we just want to set the position where it should


    if (indexRef.current === index) {
      set(function (_i) {
        var _ref4;

        return _ref4 = {}, _ref4[axis] = restPos.current, _ref4.s = 1, _ref4.config = _extends({}, releaseSpring, {
          velocity: velocity.current
        }), _ref4;
      });
    } else {
      // 2. the user has changed the index props: in that case indexRef
      // is outdated and different from index. We want to animate depending
      // on the direction of the slide, with the furthest slide moving first
      // trailing the others
      var dir = index < indexRef.current ? -1 : 1; // if direction is 1 then the first slide to animate should be the lowest
      // indexed visible slide, if -1 the highest

      var firstToMove = dir > 0 ? firstVisibleIndex.current : lastVisibleIndex.current;
      set(function (i) {
        var _ref5;

        return _ref5 = {}, _ref5[axis] = restPos.current, _ref5.s = 1, _ref5.config = releaseSpring, _ref5.delay = i * dir < firstToMove * dir ? 0 : Math.abs(firstToMove - i) * trailingDelay, _ref5;
      });
    } // finally we update indexRef to match index


    indexRef.current = index;
  }, [index, set, root, vertical, axis, height, width, releaseSpring, draggedSpring, trailingDelay]); // adding the bind listener

  var bind = reactUseGesture.useDrag(function (_ref6) {
    var first = _ref6.first,
        last = _ref6.last,
        tap = _ref6.tap,
        _ref6$vxvy = _ref6.vxvy,
        vx = _ref6$vxvy[0],
        vy = _ref6$vxvy[1],
        _ref6$delta = _ref6.delta,
        dx = _ref6$delta[0],
        dy = _ref6$delta[1],
        _ref6$swipe = _ref6.swipe,
        sx = _ref6$swipe[0],
        sy = _ref6$swipe[1],
        _ref6$movement = _ref6.movement,
        movX = _ref6$movement[0],
        movY = _ref6$movement[1],
        _ref6$args = _ref6.args,
        pressedIndex = _ref6$args[0],
        _ref6$memo = _ref6.memo,
        memo = _ref6$memo === void 0 ? springs[pressedIndex][axis].getValue() : _ref6$memo;

    if (tap) {
      onTap && onTap(pressedIndex);
      return;
    }

    var v = vertical ? vy : vx;
    var dir = -Math.sign(vertical ? dy : dx);
    var mov = vertical ? movY : movX;
    var swipe = vertical ? sy : sx;

    if (first) {
      // if this is the first drag event, we're trailing the controllers
      // to the index being dragged and setting zIndex, scale and config
      set(function (i) {
        var _ref7;

        return _ref7 = {}, _ref7[axis] = memo + mov, _ref7.s = draggedScale, _ref7.config = function config(key) {
          return key === axis && i === pressedIndex ? draggedSpring : trailingSpring;
        }, _ref7.zIndex = i === pressedIndex ? 10 : 0, _ref7;
      }); // triggering onDragStart prop if it exists

      onDragStart && onDragStart(pressedIndex);
    } else if (last) {
      // when the user releases the drag and the distance or speed are superior to a threshold
      // we update the indexRef
      if (Math.abs(mov) > size / 2 || swipe !== 0) {
        indexRef.current = clamp(indexRef.current + (mov > 0 ? -1 : 1), minIndex, maxIndex);
      } // if the index is not equal to indexRef we know we've moved a slide
      // so we tell the user to update its index in the next tick and our useEffect
      // will do the rest. RAF is used to make sure we're not updating the index
      // too fast: that might happen if the user wants to update a slide onClick
      // TODO - need an example


      if (index !== indexRef.current) {
        velocity.current = v;
        requestAnimationFrame(function () {
          return onIndexChange(indexRef.current);
        });
      } // if the index hasn't changed then we set the position back to where it should be
      else set(function () {
          var _ref8;

          return _ref8 = {}, _ref8[axis] = restPos.current, _ref8.s = 1, _ref8.config = releaseSpring, _ref8;
        }); // triggering onDragEnd prop if it exists


      onDragEnd && onDragEnd(pressedIndex);
    } // if not we're just dragging and we're just updating the position
    else {
        var firstToMove = dir > 0 ? firstVisibleIndex.current : lastVisibleIndex.current;
        set(function (i) {
          var _ref9;

          return _ref9 = {}, _ref9[axis] = mov + memo, _ref9.delay = i * dir < firstToMove * dir || i === pressedIndex ? 0 : Math.abs(firstToMove - i) * trailingDelay, _ref9.config = function config(key) {
            return key === axis && i === pressedIndex ? draggedSpring : trailingSpring;
          }, _ref9;
        });
      } // and returning memo to keep the initial position in cache along drag


    return memo;
  }, {
    enabled: enabled,
    axis: axis,
    filterTaps: true
  });
  var rootStyle = slidesWrapperStyle(vertical);
  if (!className) rootStyle.width = '100%';
  return React__default.createElement("div", {
    ref: root,
    className: className,
    style: _extends({}, rootStyle, {}, style)
  }, springs.map(function (_ref10, i) {
    var _extends2, _extends3;

    var pos = _ref10[axis],
        s = _ref10.s,
        zIndex = _ref10.zIndex;
    return React__default.createElement(reactSpring.animated.div // passing the index as an argument will let our handler know
    // which slide is being dragged
    , Object.assign({}, bind(i), {
      key: i,
      "data-index": i,
      className: slideClassName,
      style: _extends((_extends2 = {}, _extends2[vertical ? 'justifyContent' : 'alignItems'] = slideAlign, _extends2.display = 'flex', _extends2), slideStyleFunc(i), (_extends3 = {
        zIndex: zIndex
      }, _extends3[axis] = pos, _extends3.scale = s, _extends3.willChange = 'transform', _extends3))
    }), children[i]);
  }));
};
Slider.defaultProps = defaultProps;

exports.Slider = Slider;
//# sourceMappingURL=react-soft-slider.cjs.development.js.map
