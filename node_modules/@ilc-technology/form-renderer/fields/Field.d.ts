import { IForm } from '..';
import * as Validators from '../utils/validators';
import { Listenable, IListenable } from '../utils/Listenable';
import * as BusinessRules from '../utils/businessRules';
export interface BusinessRuleExecutors {
    [key: string]: BusinessRules.BusinessRuleExecutor;
}
export interface IValidationRule<T> {
    type: Validators.ValidationType;
    value: T;
    errorMessage: string;
    async: boolean;
    apply?: Validators.Validator<T, any> | Validators.AsyncValidator<T, any>;
}
export interface IBusinessRule {
    trigger: string;
    action: string;
    target: string;
    immediate?: boolean;
}
export interface IFieldConfiguration<T> {
    type: string;
    name: string;
    label?: string;
    defaultValue?: T;
    placeholder?: string;
    autocompleteValue?: string;
    validationRules?: IValidationRule<T>[];
    businessRules?: IBusinessRule[];
    additionalData?: {
        [key: string]: any;
    };
}
export interface IFieldOption {
    code: string;
    text: string;
    description?: string;
}
export interface IFieldConfigurationWithOptions<T> extends IFieldConfiguration<T> {
    options: IFieldOption[];
}
export declare type IListenerCallback<T> = (field: IField<T>) => void;
export declare type FieldEventType = 'change' | 'validationCompleted';
export interface IField<T> extends IListenable<FieldEventType, IListenerCallback<T>> {
    value: T | null;
    form: IForm;
    htmlElement?: HTMLElement;
    configuration: IFieldConfiguration<T>;
    previousValue: T;
    render: () => HTMLElement | null;
    addValidationRule: (rule: IValidationRule<T>) => void;
    validate: () => Promise<{
        outcome: boolean;
        errorList: string[];
        fullTextErrorList: string[];
    }>;
    isRequired: () => boolean;
    _required?: boolean;
    triggerChangeEvent: () => void;
}
export interface FieldHandler<T> {
    name: string;
    handler: (conf: IFieldConfiguration<T>, form: IForm) => IField<T>;
}
export interface ValidationOutcome {
    outcome: boolean;
    errorMessage: string;
}
export default abstract class Field<T> extends Listenable<FieldEventType, IListenerCallback<T>> implements IField<T> {
    static handlers: FieldHandler<any>[];
    static register(name: string, handler: (configuration: IFieldConfiguration<any>, form: IForm) => IField<any>): void;
    abstract get value(): T | null;
    abstract set value(v: T | null);
    isRequired(): boolean;
    abstract get previousValue(): T;
    static buildField(conf: IFieldConfiguration<any>, form: IForm): IField<any> | undefined;
    abstract configuration: IFieldConfiguration<T>;
    abstract htmlElement?: HTMLElement;
    abstract form: IForm;
    abstract render: () => HTMLElement | null;
    private _show;
    show(): void;
    hide(): void;
    private _validationRules;
    addValidationRule(rule: IValidationRule<T>): void;
    _applySingleValidation(value: T, rule: IValidationRule<any>): Promise<ValidationOutcome>;
    validate(): Promise<{
        outcome: boolean;
        errorList: string[];
        fullTextErrorList: string[];
    }>;
    triggerChangeEvent(): void;
}
