<h1 align="center">
	<img width="500" src="/assets/form-x-logo.png" alt="forms-x-logo">
	<br>
	<br>
</h1>

> FormsX Form Renderer

## Features

This library can be used to include the latest version of EF Forms (Forms X) in a web page.

The rendered form takes care of validation and submission, but it is completely unstyled.

## Table of contents

- [Features](#features)
- [Table of contents](#table-of-contents)
- [Requirements](#requirements)
- [Quickstart](#quickstart)
- [Usage examples](#usage-examples)
  - [Vanilla JS](#vanilla-js)
  - [Imported as a .js library](#imported-as-a-js-library)
  - [React](#react)
- [Settings](#settings)
  - [id](#id)
  - [marketCode](#marketcode)
  - [container](#container)
  - [formConfigurationEndpoint](#formconfigurationendpoint)
  - [formWrapperCSSClass](#formwrappercssclass)
  - [plugins](#plugins)
  - [applyGud](#applygud)
  - [labelAsPlaceholder](#labelasplaceholder)
- [Hooks](#hooks)
- [Plugins](#plugins-1)
  - [Create a global plugin](#create-a-global-plugin)
- [Changelog and breaking changes](#changelog-and-breaking-changes)
  - [v0.12.0](#v0120)
- [Contributing to this repository](#contributing-to-this-repository)
- [Information about release drafter](#information-about-release-drafter)
- [Problems with callbacks?](#problems-with-callbacks)

## Requirements

The only mandatory requirement to use this library is to have access to the EF NPM private registry ([documentation available here](https://docs.google.com/document/d/1YcA8SuZZhtfE2fsGvzUifJmwjuc2M479V_Tl8CzrAWI/edit?usp=sharing))

## Quickstart

Install the latest version of the library

`npm install @ilc-technology/form-renderer`

Depending on your tech stack, you might want to include it in your project with:

`import { Form } from '@ilc-technology/form-renderer';`

or, if you are using **React**, you can use the **FormWrapper**, that exposes a component ready to be used:

`import { FormWrapper } from '@ilc-technology/form-renderer/react';`

## Usage examples

### Vanilla JS

```Javascript
import { Form } from '@ilc-technology/form-renderer';

...

const form = new EF.Form({
  id: 'campaign',
  marketCode: 'de',
  container: '#form-wrapper',
  plugins: {
    tracking: {
      firstLevel: 'ils',
      secondLevel: 'brochure',
      thankYouPageName: 'thank-you'
    },
    legacySettings: {
      productCode: 'LS',
      programCode: 'AYA'
    }
  }
}).on('validationFailed', form => {
  console.log(form.validationErrors.fullTextErrorList);
})
```

### Imported as a .js library

```Html
...

<script src="//www.ef.com/hub/shared/formsx/v0.12/ef-forms.min.js"></script>

...

<script>
  const form = new EF.Form(settings)
    .on('validationFailed', form => {
      console.log(form.validationErrors.fullTextErrorList);
    })
</script>
```

### React

```JSX
import { FormWrapper } from '@ilc-technology/form-renderer/react';

...

<FormWrapper
  id="brochure"
  formWrapperId="brochure"
  marketCode={language}
  formWrapperCSSClass="ef-rhps-form"
  onValidationFailed={form => console.log(form.validationErrors.fullTextErrorList)}
  plugins={{
    tracking: {
      firstLevel: 'ils',
      secondLevel: 'brochure',
      thankYouPageName: 'thank-you'
    },
    legacySettings: {
      productCode: mapNewToOldProductCode(product).toUpperCase(),
      programCode: mapNewToOldProgramCode(product).toUpperCase(),
    }
  }}
/>
```

## Settings

The settings must follow the [IFormSettings](https://github.com/ILC-Technology/ef-form-renderer/blob/21edadfc47d953ea0fb3c95eb778ec22f0470709/src/index.ts#L31-L42) interface:

```Typescript
export interface IFormSettings {
  id: string;
  container: string;
  marketCode: string;
  applyGud?: boolean;
  labelAsPlaceholder?: string | [string];
  formConfigurationEndpoint?: string;
  formWrapperCSSClass?: string;
  plugins?: {
    [key: string]: any;
  };
}
```

As of now, they are:

#### id

Defines which type of form you want to load the configuration for, as of now they are:

- brochure
- campaign
- campaign-tttw19
- consultation
- contactus
- infomeeting
- pricequotation
- pricequotation-express

As you can see, if you'll need to use a custom version of the same form (like the TicketToTheWorld19 one), you'll find before the dash the base type of that configuration, and on the right the specific name.

#### marketCode

The marketcode is needed to receive a localized form.

The available marketcodes are, as of now:

`ae,ar,at,au,az,be,br,bx,ca,ch,cl,cn,co,cs,ct,cz,de,dk,dx,dz,ec,es,fc,fi,fr,gb,hk,hu,id,ie,ir,it,jp,kr,kz,lg,lu,lv,ly,mx,nl,no,nz,pa,pe,pl,pt,ro,ru,sa,se,sg,si,sk,th,tn,tr,tw,us,uy,ve,vn,wc,we,wl,wm,wp,wr`

#### container

Is the selector of the html element where the form should be rendered inside.

If you are using the React wrapper, you should use **formWrapperId** instead of **container**.

Look at the [Usage Examples](#usage-examples) to see how it works.

#### formConfigurationEndpoint

With this setting you can set the url where the form will fetch the configuration.

Example:

```Javascript
{
  ...
  formConfigurationEndpoint: "https://qa-forms-api.ef.com/forms/{type}/{market}",
  ...
}
```

Receiving an endpoint formatted like this, the form will replace `{type}` with the **id** set in the settings and `{market}` with the **marketCode** set in the settings.

With the [Usage Examples](#usage-examples) configuration,

`https://qa-forms-api.ef.com/forms/{type}/{market}`

will be translated in

`https://qa-forms-api.ef.com/forms/campaign/de`

#### formWrapperCSSClass

It's the class name that will be applied to the `form` element. By default it will be applied the classes: `ef-form` and `ef-form-mc-${marketCode}`.

#### plugins

Configure the plugins enabled from the [server-side](#plugins-1).

Example:

```Javascript
{
  ...
  plugins: {
    tracking: {
      firstLevel: 'ils',
      secondLevel: 'brochure',
      thankYouPageName: 'thank-you'
    }
  }
}
```

The list of possible plugins as of now is:

- **google-maps-script**:

  _No traces found in the codebase._

- **google-places**:

  _Internally loaded plugin, no traces found in the codebase._

- **moment**:

  _This is an externally loaded plugin, no configuration needed. If present in the configuration downloaded, it will be used to manage the DateTimes while rendering a datepicker._

- **pikaday**:

  _This is an externally loaded plugin, no configuration needed. If present in the configuration downloaded, it will be used to render a datepicker._

- **tracking**:

  _Those are used to set a custom page name `${firstLevel}:${secondLevel}:[${thankYouPageName}]` and it will be set in the `window.setPageNameDependentProps`._

  ```Javascript
  {
    firstLevel: string,
    secondLevel: string,
    thankYouPageName: string
  }
  ```

- **v4-adapter**:

  _will not accept a configuration, it is needed to adapt the answer to the format of the old service that will accept the payload. To configure it, the plugin configuration **legacySettings** will be used._

- **legacySettings**:

  _is a special plugin configuration, it is used only in the v4-adapter plugin, and you can specify:_

  ```Javascript
  {
    productCode: string,
    programCode: string,
    websiteId: string,
    campaignAllocationPrograms: {
      programs: string[]
    },
    isCompleted: boolean,
    brandAmbassadorId: string,
  }
  ```

#### applyGud

If set to true, GUD classes will be applied to the form elements, according to the [documentation](https://code.ef.design/forms/inputs?version=react).
You will also need to include the [latest CSS for the GUD](https://cdn.ef.design/libs/web-ui/latest/css/bundle.min.css) to see the styiling applied properly.

(default false)

#### labelAsPlaceholder

It can be set as a field type (i.e.: text or textarea), or as a field name (i.e.: comments). Array of strings (either field names or types) are also accepted.
If a field in the form matches the name or the type specified, than the label of that field will be rendered as the placeholder of the element, instead of being put as a standalone DOM element.

(default null)

## Hooks

You can listen on events during the lifecycle of the form to inject custom code.

Events list:

- **configurationDownloaded**: _executed in the render function, when a configuration is download_
- **formRendered**: _executed in the render function, when the form is rendered_
- **formView**: _executed in the render function, when the form has rendered correctly_
- **validationFailed**: _executed in the submit function, executed if at least one validation has failed_
- **submissionObjectReady**: _executed in the submit function, executed if all validation where successfull_
- **submissionCompleted**: _executed in the submit function, after **submissionObjectReady** if the request to the remote endpoint is successfull_
- **submissionFailed**: _same as **submissionCompleted**, but executed if the request fails_

Every event has a **pre** and **post hooks**, example:

- preconfigurationDownloaded
- configurationDownloaded
- postconfigurationDownloaded

## Plugins

There are a set of plugins [already included in the project](https://github.com/ILC-Technology/ef-form-renderer/tree/f0d5153741ee72b5cd80ad4c00076145f5c188d2/src/plugins) and they are registered inside the `Form` class in a [key-function dictionary](https://github.com/ILC-Technology/ef-form-renderer/blob/f0d5153741ee72b5cd80ad4c00076145f5c188d2/src/Form.ts#L367).

Each of these plugins accepts a `Form` object and have a return of type `void`.

Reading the configuration of the form that has to be rendered the `Form` knows which plugin to load, for example, for an `ae` `brochure`:

```Javascript
{
  ...
  "form": {
    "form": {
      "fields": []
    },
    ...
    "scriptFiles": [
      {
        "pluginName": "v4-adapter"
      },
      {
        "pluginName": "google-maps-script",
        "pluginPath": "//maps.googleapis.com/maps/api/js?v=3.exp&components=country:de&key=AIzaSyBlsJhXxayG7Xedc0X5tgXp2yWk1fK4FXU&libraries=places&language=de"
      },
      ...
    ]
  }
}
```

We see that, server side, plugins must be enabled with just the `pluginName` if already included in the `Form` or, specifying also `pluginPath` they can be loaded also externally and registered inside the `Form`.

What you can do client-side is defining the attributes for these plugins, and this is done with the [plugins](#plugins) setting.

External plugins [will be appended](https://github.com/ILC-Technology/ef-form-renderer/blob/e47496f6e8e113ee9528d121c97a4e6b67add000/src/utils/misc.ts#L4) to the window element.

### Create a Global Plugin

A global plugin is a plugin which source code is part of this repo and it can be used by every form when specified in their configuration.

To define a global plugin, add your source code in the `src/plugins` folder.

You'll have to define a default export with a callback that will receive as an input an `IForm`. With that you can write events that will connects to the form hooks.

To enable the plugin, you'll have to register it in the `src/index.ts` with the function `registerGlobalPlugin`. You'll have to assign the label to trigger your plugin.

To trigger it, the configuration loaded from the backend needs to specify its label name in the array `scriptFiles`.

## Qualifying Question (QQ)

### Introduction

The Qualifying Question (QQ) is a piece of business logic needed to allocate the user to the most appropriate EF program based on the response to a set of questions.

As of 4 Nov. 2020, the business logic is based on the [V8 Revision](https://ef-ilc.atlassian.net/wiki/spaces/LGEN/pages/779845707/QQ+V8+Revision):

QQ is automatically plugged in whenever one of the following form configuration types is used:

- **brochure-qq-multi**: Brochure base type form, multiple products QQ

- **brochure-qq-lang**: Brochure base type form, Language QQ

- **campaign-qq-lang**: Campaign base type form, Language QQ

This happens in the v4-adapter plugin, which makes use of the _QQManager_ utils class, which is where the QQ business logic lives.

Since the purpose of QQ is to allocate the user on a specific program code, it can be disabled by providing an overriding program code when Form is instantiated by passing a programCode in the legacySettings plugin.

For example, this will force a program code allocation and disable QQ if a prog parameter exists in the query string:

```Javascript
import getQueryStringParam from '../my-utils/getQueryStringParam';

<FormWrapper
  marketCode={marketCode}
  id="campaign-qq-lang"
  formWrapperId="form-wrapper"
  onSubmissionCompleted={onSubmissionCompleted}
  plugins={{
    legacySettings: {
      programCode: getQueryStringParam('prog') || undefined
    },
  }}
/>
```

### API Dependencies

QQ depends on different APIs needed to gather the data necessary to the business logic.

- **Programs Availability** : The data regarding the available programs on a given market is fetched from the EF Central API. The endpoint is defined in _config.endpoint.programsApi_.

- **Age Categories** : The data regarding the age brackets on a given market is fetched from the EF Central API. The endpoint is defined in _config.endpoint.ageCategoriesApi_.

- **QQ Program Allocation** : On submit, the QQ allocation program code is fetched from the Secure Forms API. The endpoint is defined in _config.endpoint.qqProgramAllocationApi_. As of Nov 5. the usage of this API is currently disabled in favor of a hardcoded business logic solution, because the API is returning incorrect program allocation data.

Reference contact person for the EF Central API: _Nadir Khan (London)_.

Reference contact person for the Secure Forms API: _Venkateshgowda K (Bangalore)_.

## Changelog and breaking changes

See `Releases` on github (on the right side of the menu). If you need to add some more information, please edit the draft version of the release.

## Contributing to this repository

The below is a short description how you can contribute to this repository. It's work in progress (but up-to-date, so you should use it), as we currently are testing a new setup with github actions.

### 1. Create a PR against `dev` branch

Our release process is automated and driven by the commits we make to the repository. There are two main branches we are concerned about when it comes to releases.

- `dev` this is the main branch we work off of. Any pull requests should be made against this branch.When a commit is pushed here it is evaluated by [semantic-release](https://semantic-release.gitbook.io/semantic-release/) to determine if a release should occur. All releases made on this branch are done on the `next` distribution channel (eg. if version 2.1.0 was released on dev you could install it locally with `npm install @ilc-technology/form-renderer@next`).
- `master` this is the "production ready" branch. When dev is merged to master, semantic release will move any releases on that branch to the default `latest` distribution channel (i.e. running `npm install @ilc-technology/form-renderer` will install these releases).

For this process to work, all commits must follow the [comventional commits](https://www.conventionalcommits.org/en/v1.0.0/) standard. We use [commitlint](https://commitlint.js.org/#/) to enforce this each time you make a commit. If you don't want to worry about formatting your commit you can use [commitizen](http://commitizen.github.io/cz-cli/) to answer a few prompts and have it do the formatting for you. Simply run `npx cz`.

Here is an example of the release type that will be done based on a commit messages:

| Commit message | Release type  |
| ---------------|-------------- |
| `fix(pencil): stop graphite breaking when too much pressure applied`| Patch Release |
| `feat(pencil): add 'graphiteWidth' option`| Minor Release |
| `perf(pencil): remove graphiteWidth option`<br><br>`BREAKING CHANGE: The graphiteWidth option has been removed.`<br>`The default graphite width of 10mm is always used for performance reasons.` | Major Release |  

## Problems with callbacks?

Have a look here https://github.com/ILC-Technology/efway/blob/5eef8eb2496d0c1273875864fe0256b968012108/components/FormSection/index.js#L7 and here https://github.com/ILC-Technology/efway/pull/21 for a very poor fix. The below quote from the comments of the mentioned PR might be useful if you ever find yourself having some trouble with ef-form-renderer callbacks.

```
// Hack for ef-form-renderer which keeps outdated callbacks. The below
// variable (uglyHackState) needs to be outside of the functional component
// as this solution depends on JavaScript's pass-by-reference behavior and
// React's overwriting of variables during re-renders.
// If the variable is inside the component, the reference is lost during re-renders.
//
// The ef-form-renderer's callbacks are outdated/stale because ef-form-renderer
// assigns the props only on componentDidMount and does not take "latest
// version" of them later on. This fix can be refactored once ef-form-renderer
// callback passing will get fixed.
```
