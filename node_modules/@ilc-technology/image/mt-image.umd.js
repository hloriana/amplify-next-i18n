(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
    typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
    (global = global || self, factory(global.MtImage = {}, global.React));
}(this, (function (exports, React) { 'use strict';

    React = React && React.hasOwnProperty('default') ? React['default'] : React;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    var STORYBLOK_IMAGE_SIZE_LIMIT = 4000;
    var QUALITY_DEFAULT = 75;
    var STORYBLOK_IMAGE_DOMAIN = /(https:)?\/\/(s3.amazonaws.com\/)?a.storyblok.com/;
    var IS_WEBP_SUPPORTED = 'isWebpSupported';
    function canUseWebp() {
      if (typeof document !== 'object') {
        // not in browser
        return false;
      }

      var isWebpSupported = sessionStorage.getItem(IS_WEBP_SUPPORTED);

      if (isWebpSupported === null) {
        isWebpSupported = (document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') === 0).toString();
        sessionStorage.setItem(IS_WEBP_SUPPORTED, isWebpSupported);
      }

      return isWebpSupported === 'true';
    }
    var resizeWithFocusPoint = function resizeWithFocusPoint(image, size, focusPoint, quality) {
      if (quality === void 0) {
        quality = QUALITY_DEFAULT;
      }

      if (image === undefined || image.length === 0) return {
        url: '',
        urlWebp: '',
        size: {
          width: 0,
          height: 0
        }
      }; //if we are dealing with an svg we don't crop/resize the image

      if (image.endsWith('.svg')) {
        return {
          url: image,
          urlWebp: '',
          size: size
        };
      }

      var imageOptions = "filters:quality(" + quality + ")";
      var originalSize = getImageSize(image);

      if (originalSize) {
        if (size.width > originalSize.width || size.height > originalSize.height) {
          size = originalSize;
        } // as the service only allows images up to 4000x4000 we do some math to make sure the resize is correct


        size = calculateMaxSize(size, STORYBLOK_IMAGE_SIZE_LIMIT); // this bit is to deal with resize coordinates if image original size is bigger than STORYBLOK_IMAGE_SIZE_LIMIT

        var maxOriginalSize = calculateMaxSize(originalSize, STORYBLOK_IMAGE_SIZE_LIMIT);
        var sizeOption = size.width + "x" + size.height + "/";
        var focusInPx = {
          x: Math.round(maxOriginalSize.width * focusPoint.x / 100),
          y: Math.round(maxOriginalSize.height * focusPoint.y / 100)
        }; // https://www.storyblok.com/docs/image-service
        // filters:focal(<left>x<top>:<right>x<bottom>)

        var focusPointOption = ":focal(" + focusInPx.x + "x" + focusInPx.y + ":" + (focusInPx.x + 1) + "x" + (focusInPx.y + 1) + ")";
        imageOptions = sizeOption + imageOptions + focusPointOption;
      }

      var formatOption = ':format(webp)';
      var imageService = "https://img2.storyblok.com/";
      var path = image.replace(STORYBLOK_IMAGE_DOMAIN, '');
      return {
        url: imageService + imageOptions + path,
        urlWebp: imageService + imageOptions + formatOption + path,
        size: size
      };
    };
    var getImageSize = function getImageSize(imageUrl) {
      var sizeRegex = /.*a\.storyblok\.com\/f\/.+\/(\d+)x(\d+)\//;
      var sizesFound = imageUrl.match(sizeRegex);

      if (sizesFound) {
        return {
          width: parseInt(sizesFound[1]),
          height: parseInt(sizesFound[2])
        };
      }

      return undefined;
    };
    var calculateMaxSize = function calculateMaxSize(size, sizeLimit) {
      var newSize = size;

      if (newSize.width > sizeLimit) {
        newSize.height = Math.round(sizeLimit * size.height / size.width);
        newSize.width = sizeLimit;
      }

      if (newSize.height > sizeLimit) {
        newSize.width = Math.round(sizeLimit * size.width / size.height);
        newSize.height = sizeLimit;
      }

      return newSize;
    };

    var SBLoader = function SBLoader(_a) {
      var src = _a.src,
          width = _a.width,
          quality = _a.quality;
      var resizedImage = resizeWithFocusPoint(src, {
        width: width,
        height: 0
      }, {
        x: 50,
        y: 50
      }, quality);
      return canUseWebp() && resizedImage.urlWebp !== '' ? resizedImage.urlWebp : resizedImage.url;
    };

    var MtImage = function MtImage(_a) {
      var imageUrl = _a.imageUrl,
          size = _a.size,
          alt = _a.alt,
          wrapperClassname = _a.wrapperClassname,
          ImageComp = _a.image,
          all = __rest(_a, ["imageUrl", "size", "alt", "wrapperClassname", "image"]);

      var imageSize = getImageSize(imageUrl);
      return React.createElement("div", {
        className: wrapperClassname
      }, !STORYBLOK_IMAGE_DOMAIN.test(imageUrl) ? React.createElement("img", __assign({
        src: imageUrl,
        alt: alt
      }, all)) : size && imageSize ? React.createElement(ImageComp, __assign({
        loader: SBLoader,
        src: imageUrl,
        alt: alt,
        width: imageSize.width,
        height: imageSize.height
      }, all)) : React.createElement(ImageComp, __assign({
        loader: SBLoader,
        src: imageUrl,
        alt: alt,
        layout: "fill"
      }, all)));
    };

    exports.MtImage = MtImage;
    exports.QUALITY_DEFAULT = QUALITY_DEFAULT;
    exports.SBLoader = SBLoader;
    exports.STORYBLOK_IMAGE_DOMAIN = STORYBLOK_IMAGE_DOMAIN;
    exports.STORYBLOK_IMAGE_SIZE_LIMIT = STORYBLOK_IMAGE_SIZE_LIMIT;
    exports.calculateMaxSize = calculateMaxSize;
    exports.canUseWebp = canUseWebp;
    exports.getImageSize = getImageSize;
    exports.resizeWithFocusPoint = resizeWithFocusPoint;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
