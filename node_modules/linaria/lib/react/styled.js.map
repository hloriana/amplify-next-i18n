{"version":3,"sources":["../../src/react/styled.ts"],"names":["restOp","obj","keysToExclude","Object","keys","filter","prop","includes","reduce","acc","curr","assign","warnIfInvalid","value","componentName","process","env","NODE_ENV","isFinite","stringified","JSON","stringify","String","console","warn","styled","tag","options","Array","isArray","Error","render","props","ref","as","component","className","class","rest","filteredProps","indexOf","key","vars","style","name","variable","result","unit","__linaria","React","createElement","Result","forwardRef","innerRef","displayName","extends","Proxy","get","o"],"mappings":"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","sourcesContent":["/**\n * This file contains an runtime version of `styled` component. Responsibilities of the component are:\n * - returns ReactElement based on HTML tag used with `styled` or custom React Component\n * - injects classNames for the returned component\n * - injects CSS variables used to define dynamic styles based on props\n */\nimport * as React from 'react'; // eslint-disable-line import/no-extraneous-dependencies\nimport validAttr from '@emotion/is-prop-valid';\nimport { cx } from '../index';\nimport type { CSSProperties } from '../CSSProperties';\nimport type { StyledMeta } from '../StyledMeta';\n\nexport type NoInfer<A extends any> = [A][A extends any ? 0 : never];\n\ntype Options = {\n  name: string;\n  class: string;\n  vars?: {\n    [key: string]: [\n      string | number | ((props: unknown) => string | number),\n      string | void\n    ];\n  };\n};\n\n// Workaround for rest operator\nconst restOp = (\n  obj: { [key: string]: any },\n  keysToExclude: string[]\n): { [key: string]: any } =>\n  Object.keys(obj)\n    .filter((prop) => !keysToExclude.includes(prop))\n    .reduce((acc, curr) => Object.assign(acc, { [curr]: obj[curr] }), {}); // rest operator workaround\n\nconst warnIfInvalid = (value: any, componentName: string) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (\n      typeof value === 'string' ||\n      // eslint-disable-next-line no-self-compare\n      (typeof value === 'number' && isFinite(value))\n    ) {\n      return;\n    }\n\n    const stringified =\n      typeof value === 'object' ? JSON.stringify(value) : String(value);\n\n    // eslint-disable-next-line no-console\n    console.warn(\n      `An interpolation evaluated to '${stringified}' in the component '${componentName}', which is probably a mistake. You should explicitly cast or transform the value to a string.`\n    );\n  }\n};\n\n// If styled wraps custom component, that component should have className property\nfunction styled<TConstructor extends React.FunctionComponent<any>>(\n  tag: TConstructor extends React.FunctionComponent<infer T>\n    ? T extends { className?: string }\n      ? TConstructor\n      : never\n    : never\n): ComponentStyledTag<TConstructor>;\nfunction styled<T>(\n  tag: T extends { className?: string } ? React.ComponentType<T> : never\n): ComponentStyledTag<T>;\nfunction styled<TName extends keyof JSX.IntrinsicElements>(\n  tag: TName\n): HtmlStyledTag<TName>;\nfunction styled(tag: any): any {\n  return (options: Options) => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (Array.isArray(options)) {\n        // We received a strings array since it's used as a tag\n        throw new Error(\n          'Using the \"styled\" tag in runtime is not supported. Make sure you have set up the Babel plugin correctly. See https://github.com/callstack/linaria#setup'\n        );\n      }\n    }\n\n    const render = (props: any, ref: any) => {\n      const { as: component = tag, class: className } = props;\n      const rest = restOp(props, ['as', 'class']);\n      let filteredProps;\n\n      // Check if it's an HTML tag and not a custom element\n      if (typeof component === 'string' && component.indexOf('-') === -1) {\n        filteredProps = {} as { [key: string]: any };\n\n        // eslint-disable-next-line guard-for-in\n        for (const key in rest) {\n          if (key === 'as' || validAttr(key)) {\n            // Don't pass through invalid attributes to HTML elements\n            filteredProps[key] = rest[key];\n          }\n        }\n      } else {\n        filteredProps = rest;\n      }\n\n      filteredProps.ref = ref;\n      filteredProps.className = cx(\n        filteredProps.className || className,\n        options.class\n      );\n\n      const { vars } = options;\n\n      if (vars) {\n        const style: { [key: string]: string } = {};\n\n        // eslint-disable-next-line guard-for-in\n        for (const name in vars) {\n          const variable = vars[name];\n          const result = variable[0];\n          const unit = variable[1] || '';\n          const value = typeof result === 'function' ? result(props) : result;\n\n          warnIfInvalid(value, options.name);\n\n          style[`--${name}`] = `${value}${unit}`;\n        }\n\n        filteredProps.style = Object.assign(style, filteredProps.style);\n      }\n\n      if ((tag as any).__linaria && tag !== component) {\n        // If the underlying tag is a styled component, forward the `as` prop\n        // Otherwise the styles from the underlying component will be ignored\n        filteredProps.as = component;\n\n        return React.createElement(tag, filteredProps);\n      }\n      return React.createElement(component, filteredProps);\n    };\n\n    const Result = React.forwardRef\n      ? React.forwardRef(render)\n      : // React.forwardRef won't available on older React versions and in Preact\n        // Fallback to a innerRef prop in that case\n        (props: any) => {\n          const rest = restOp(props, ['innerRef']);\n          return render(rest, props.innerRef);\n        };\n\n    (Result as any).displayName = options.name;\n\n    // These properties will be read by the babel plugin for interpolation\n    (Result as any).__linaria = {\n      className: options.class,\n      extends: tag,\n    };\n\n    return Result;\n  };\n}\n\ntype StyledComponent<T> = StyledMeta &\n  (T extends React.FunctionComponent<any>\n    ? T\n    : React.FunctionComponent<T & { as?: React.ElementType }>);\n\ntype StaticPlaceholder = string | number | CSSProperties | StyledMeta;\n\ntype HtmlStyledTag<TName extends keyof JSX.IntrinsicElements> = <\n  TAdditionalProps = {}\n>(\n  strings: TemplateStringsArray,\n  ...exprs: Array<\n    | StaticPlaceholder\n    | ((\n        // Without Omit here TS tries to infer TAdditionalProps\n        // from a component passed for interpolation\n        props: JSX.IntrinsicElements[TName] & Omit<TAdditionalProps, never>\n      ) => string | number)\n  >\n) => StyledComponent<JSX.IntrinsicElements[TName] & TAdditionalProps>;\n\ntype ComponentStyledTag<T> = <\n  OwnProps = {},\n  TrgProps = T extends React.FunctionComponent<infer TProps> ? TProps : T\n>(\n  strings: TemplateStringsArray,\n  // Expressions can contain functions only if wrapped component has style property\n  ...exprs: TrgProps extends { style?: React.CSSProperties }\n    ? Array<\n        | StaticPlaceholder\n        | ((props: NoInfer<OwnProps & TrgProps>) => string | number)\n      >\n    : StaticPlaceholder[]\n) => keyof OwnProps extends never\n  ? T extends React.FunctionComponent<any>\n    ? StyledMeta & T\n    : StyledComponent<TrgProps>\n  : StyledComponent<OwnProps & TrgProps>;\n\ntype StyledJSXIntrinsics = {\n  readonly [P in keyof JSX.IntrinsicElements]: HtmlStyledTag<P>;\n};\n\nexport type Styled = typeof styled & StyledJSXIntrinsics;\n\nexport default (process.env.NODE_ENV !== 'production'\n  ? new Proxy(styled, {\n      get(o, prop: keyof JSX.IntrinsicElements) {\n        return o(prop);\n      },\n    })\n  : styled) as Styled;\n"],"file":"styled.js"}